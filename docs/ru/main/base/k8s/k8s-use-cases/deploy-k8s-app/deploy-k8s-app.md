Развертывание приложения в Kubernetes (k8s) осуществляется с помощью утилиты kubectl. Полный синтаксис команд утилиты можно найти в [официальной документации](https://kubernetes.io/docs/reference/kubectl/overview/).

## Подготовка

Kubectl работает в командной строке или терминале.

Убедиться что kubectl установлен можно при помощи команды:

```
kubectl version --client
```

Общий формат команды kubectl:  kubectl action resource (kubectl -> действие -> сущность, на которую направлено действие)

Эта последовательность команд выполняет указанное действие (например, создание, описание) для указанного ресурса (например, узла, контейнера). Можно использовать --help после команды, чтобы получить дополнительную информацию о возможных параметрах, например

```
kubectl get nodes --help
```

Перед выполнением работы на кластере необходимо подключиться к нему, предварительно импортировав конфигурационный файл, загруженный при создании кластера:

```
export KUBECONFIG=<путь к файлу>
```

Убедитесь, что kubectl настроен для взаимодействия с вашим кластером, выполнив команду kubectl version:

```
kubectl cluster-info
```

В ответ должно получиться примерно следующее:

Просмотреть узлы в кластере можно при помощи команды:

```
kubectl get nodes
```

Должно получиться примерно следующее:

```
kubectl get nodes
NAME       STATUS   ROLES    AGE    VERSION
k8s-cl01   Ready    master   8m4s   v1.17.3
```

Отображаются доступные узлы. Kubernetes выберет где развернуть приложение в зависимости от доступных ресурсов Node.

## Развертывание приложения

Развернем первое приложение в Kubernetes с помощью команды kubectl create deployment. Нужно указать имя развертывания и расположение образа приложения.

```
kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
deployment.apps/kubernetes-bootcamp created
```

В результате выполнения команд было развернуто приложение. Это включало несколько этапов:

- поиск подходящего узла, на котором можно было бы запустить экземпляр приложения
- планирование запуска приложения на этом узле
- настройка кластера, чтобы при необходимости запустить экземпляр на новом узле

Чтобы вывести список деплойментов, используется команда get deployments:

```
kubectl get deployments
```

Результатом выполнения команды будет:

```
kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           3m41s
```

В выводе отражен 1 деплоймент с одним экземпляром приложения. Экземпляр работает внутри контейнера Docker на узле.

## Просмотр приложения

Поды, работающие внутри Kubernetes, работают в частной изолированной сети. По умолчанию они видны из других подов и сервисов в том же кластере Kubernetes, но не за пределами этой сети. Когда используется kubectl, осуществляется взаимодействие через конечную точку API для связи с приложением.

Kubectl может создать прокси, который будет пересылать сообщения в частную сеть всего кластера. Прокси-сервер можно завершить, нажав Ctrl-C, и он не будет показывать никаких результатов во время работы.

Следующим шагом запустим прокси в новом окне командной строки или терминала:

```
echo -e "\n\n\n\e[92mStarting Proxy. After starting it will not output a response. Please click the first Terminal Tab\n";
```

Затем нужно выполнить команду kubectl proxy:

```
kubectl proxy
Starting to serve on 127.0.0.1:8001
```

После этого появляется соединение между хостом (онлайн-терминалом) и кластером Kubernetes. Прокси-сервер обеспечивает прямой доступ к API с этих терминалов.

Можно увидеть все API, размещенные через конечную точку прокси. Например, можно запросить версию напрямую через API, используя команду curl:

```
curl http://localhost:8001/version
```

Результатом вывода команды будет:

```
{
  "major": "1",
  "minor": "17",
  "gitVersion": "v1.17.3",
  "gitCommit": "06ad960bfd03b39c8310aaf92d1e7c12ce618213",
  "gitTreeState": "clean",
  "buildDate": "2020-02-11T18:07:13Z",
  "goVersion": "go1.13.6",
  "compiler": "gc",
  "platform": "linux/amd64"
}
```

Если порт 8001 недоступен, необходимо убедиться, что прокси kubectl запущен.

Сервер API автоматически создаст конечную точку для каждого модуля на основе имени модуля, который также доступен через прокси.

Сначала нужно получить имя Pod, и сохранить в переменной окружения POD_NAME:

```
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Name of the Pod: $POD_NAME
```

Должно получиться примерно следующее:

```
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Name of the Pod: $POD_NAME
Name of the Pod: kubernetes-bootcamp-69fbc6f4cf-c7khc
```

**Примечание**

Прокси-сервер запускался в новой вкладке (Терминал 2), а последние команды выполнялись на исходной вкладке (Терминал 1). Прокси-сервер по-прежнему работает на второй вкладке, и это позволило команде curl работать с использованием localhost: 8001
